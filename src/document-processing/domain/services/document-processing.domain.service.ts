import {
  Injectable,
  Logger,
  NotFoundException,
  ForbiddenException,
  Inject,
  Optional,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Cron, CronExpression } from '@nestjs/schedule';
import { DocumentRepositoryPort } from '../ports/document.repository.port';
import { StorageServicePort } from '../ports/storage.service.port';
import { OcrServicePort } from '../ports/ocr.service.port';
import { Document } from '../entities/document.entity';
import { ExtractedField } from '../entities/extracted-field.entity';
import { DocumentStatus } from '../enums/document-status.enum';
import { DocumentType } from '../enums/document-type.enum';
import { ProcessingMethod } from '../enums/processing-method.enum';
import { AllConfigType } from '../../../config/config.type';
import { AuditService } from '../../../audit/audit.service';
import { extractEntitiesFromText } from '../../utils/text-entity-extractor';
import { Pdf2JsonService } from '../../infrastructure/pdf-extraction/pdf2json.service';
import { OcrMergeService } from '../../utils/ocr-merge.service';
import { OcrPostProcessorService } from '../../utils/ocr-post-processor.service';

// Use require for pdf-parse (CommonJS module)
// pdf-parse exports { PDFParse } as a named export
// eslint-disable-next-line @typescript-eslint/no-require-imports
const { PDFParse: pdfParse } = require('pdf-parse');

export enum DocumentEventType {
  DOCUMENT_UPLOADED = 'DOCUMENT_UPLOADED',
  DOCUMENT_PROCESSING_STARTED = 'DOCUMENT_PROCESSING_STARTED',
  DOCUMENT_PROCESSING_COMPLETED = 'DOCUMENT_PROCESSING_COMPLETED',
  DOCUMENT_PROCESSING_FAILED = 'DOCUMENT_PROCESSING_FAILED',
  DOCUMENT_ACCESSED = 'DOCUMENT_ACCESSED',
  DOCUMENT_DELETED = 'DOCUMENT_DELETED',
  DOCUMENT_HARD_DELETED = 'DOCUMENT_HARD_DELETED',
  UNAUTHORIZED_DOCUMENT_ACCESS = 'UNAUTHORIZED_DOCUMENT_ACCESS',
}

/**
 * Domain Service for Document Processing
 *
 * Business logic for document upload, OCR processing, and lifecycle management.
 * All PHI handling must comply with HIPAA requirements.
 */
@Injectable()
export class DocumentProcessingDomainService {
  private readonly logger = new Logger(DocumentProcessingDomainService.name);
  private readonly retentionYears: number;
  private readonly maxRetryCount = 3;

  constructor(
    @Inject('DocumentRepositoryPort')
    private readonly documentRepository: DocumentRepositoryPort,
    @Inject('StorageServicePort')
    private readonly storageService: StorageServicePort,
    @Inject('OcrServicePort')
    private readonly ocrService: OcrServicePort, // Backward compatibility
    @Inject('VisionOcrServicePort')
    private readonly visionOcrService: OcrServicePort,
    @Inject('DocumentAiOcrServicePort')
    private readonly documentAiOcrService: OcrServicePort,
    private readonly ocrMergeService: OcrMergeService,
    private readonly auditService: AuditService,
    private readonly configService: ConfigService<AllConfigType>,
    private readonly pdf2JsonService: Pdf2JsonService,
    @Optional()
    private readonly ocrPostProcessorService?: OcrPostProcessorService,
  ) {
    this.retentionYears = this.configService.getOrThrow(
      'documentProcessing.retentionYears',
      { infer: true },
    );
  }

  /**
   * Upload document and initiate processing
   */
  async uploadDocument(
    userId: string | number,
    fileBuffer: Buffer,
    fileName: string,
    mimeType: string,
    documentType: DocumentType,
    description?: string,
  ): Promise<Document> {
    try {
      // 1. Create domain entity (initial state)
      const document = new Document();
      // NOTE: ID will be auto-generated by database as UUID
      document.userId = userId;
      document.documentType = documentType;
      document.status = DocumentStatus.UPLOADED;
      document.fileName = fileName;
      document.fileSize = fileBuffer.length;
      document.mimeType = mimeType;
      document.description = description;
      document.rawFileUri = ''; // Will be set after upload
      document.uploadedAt = new Date();
      document.createdAt = new Date();
      document.updatedAt = new Date();
      document.retryCount = 0;

      // 2. Save to database (get UUID from database)
      const savedDocument = await this.documentRepository.save(document);

      // 3. Upload to GCS
      const gcsUri = await this.storageService.storeRaw(fileBuffer, {
        documentId: savedDocument.id,
        userId,
        fileName,
        mimeType,
        contentLength: fileBuffer.length,
      });

      // 4. Update document with GCS URI and status
      await this.documentRepository.updateStatus(
        savedDocument.id,
        DocumentStatus.STORED,
        {
          rawFileUri: gcsUri,
        },
      );

      // 5. Audit log
      this.auditService.logAuthEvent({
        userId,
        provider: 'document-processing',
        event: DocumentEventType.DOCUMENT_UPLOADED as any,
        success: true,
        metadata: {
          documentId: savedDocument.id,
          documentType,
          fileSize: fileBuffer.length,
        },
      });

      this.logger.log(
        `Document uploaded: ${savedDocument.id} (user: ${userId})`,
      );

      // 6. Trigger async processing (don't await) - pass buffer for PDF analysis
      this.startProcessing(
        savedDocument.id,
        gcsUri,
        mimeType,
        fileBuffer,
      ).catch((error) => {
        this.logger.error(
          `Failed to start processing for document ${savedDocument.id}: ${error.message}`,
        );
      });

      return savedDocument;
    } catch (error) {
      this.logger.error(`Upload failed: ${error.message}`);
      throw error;
    }
  }

  /**
   * Start OCR processing (async) - now with intelligent PDF routing
   */
  private async startProcessing(
    documentId: string,
    gcsUri: string,
    mimeType: string,
    fileBuffer?: Buffer,
  ): Promise<void> {
    try {
      // Update status to PROCESSING
      await this.documentRepository.updateStatus(
        documentId,
        DocumentStatus.PROCESSING,
        {
          processingStartedAt: new Date(),
        },
      );

      const document = await this.documentRepository.findById(documentId);
      if (!document) throw new Error('Document not found');

      // Audit log
      this.auditService.logAuthEvent({
        userId: document.userId,
        provider: 'document-processing',
        event: DocumentEventType.DOCUMENT_PROCESSING_STARTED as any,
        success: true,
        metadata: { documentId },
      });

      // INTELLIGENT PDF ROUTING
      let ocrResult: any;
      let processingMethod: ProcessingMethod;

      this.logger.log(
        `[PDF PROCESSING] Starting processing for document ${documentId}`,
      );
      this.logger.log(
        `[PDF PROCESSING] MimeType: ${mimeType}, Has buffer: ${!!fileBuffer}`,
      );

      if (mimeType === 'application/pdf' && fileBuffer) {
        // Try pdf2json extraction first
        try {
          this.logger.log(
            `[PDF2JSON] Starting pdf2json extraction for document ${documentId}...`,
          );
          this.logger.debug(
            `[PDF2JSON] Buffer size: ${fileBuffer.length} bytes, MimeType: ${mimeType}`,
          );

          const { chunks, meta } =
            await this.pdf2JsonService.parseBuffer(fileBuffer);

          this.logger.log(
            `[PDF2JSON] Extraction complete: ${chunks.length} chunks from ${meta.Pages?.length} pages`,
          );

          // Log sample chunk for debugging
          if (chunks.length > 0) {
            this.logger.log(
              `[PDF2JSON] Chunk sample: ${chunks[0]?.content.substring(0, 200)}`,
            );
          }

          // Combine all chunk content for entity extraction
          const fullText = chunks.map((c) => c.content).join('\n');
          this.logger.log(`[PDF2JSON] Full text length: ${fullText.length}`);

          // Check if we got meaningful text
          if (fullText.trim().length < 50) {
            this.logger.warn(
              `[PDF2JSON] Insufficient text extracted (${fullText.length} chars), falling back to OCR`,
            );
            throw new Error(
              `Insufficient text content: ${fullText.length} characters`,
            );
          }

          // Extract entities from combined text using regex patterns
          const entities = extractEntitiesFromText(fullText);
          this.logger.log(
            `[PDF2JSON] Extracted ${entities.length} entities from text`,
          );

          ocrResult = {
            text: fullText,
            confidence: 1.0, // Native text = 100% confidence
            pageCount: meta.Pages?.length || chunks.length,
            entities, // Use regex-based entity extraction
            fullResponse: {
              method: 'pdf2json_extraction',
              chunks, // Include structured chunks
              metadata: meta.Meta || {},
            },
          };

          processingMethod = ProcessingMethod.DIRECT_EXTRACTION;

          // Run OCR in parallel even when DIRECT_EXTRACTION succeeds
          // This provides Vision and Document AI outputs for comparison
          this.logger.log(
            `[DIRECT_EXTRACTION] Direct extraction succeeded. Running OCR in parallel for comparison outputs.`,
          );

          try {
            const [visionResult, documentAiResult] = await Promise.allSettled([
              this.visionOcrService.processDocument(
                gcsUri,
                mimeType,
                document.pageCount,
              ),
              this.documentAiOcrService.processDocument(
                gcsUri,
                mimeType,
                document.pageCount,
              ),
            ]);

            const visionOcrResult =
              visionResult.status === 'fulfilled' ? visionResult.value : null;
            const documentAiOcrResult =
              documentAiResult.status === 'fulfilled'
                ? documentAiResult.value
                : null;

            // Store OCR results in fullResponse for comparison endpoints
            if (!ocrResult.fullResponse || typeof ocrResult.fullResponse !== 'object') {
              ocrResult.fullResponse = {};
            }

            // IMPORTANT: Serialize to avoid circular references
            if (visionOcrResult) {
              ocrResult.fullResponse.rawVisionResult = this.serializeOcrResult(visionOcrResult);
              this.logger.log(
                `[DIRECT_EXTRACTION] Stored Vision AI output for comparison`,
              );
            } else if (visionResult.status === 'rejected') {
              ocrResult.fullResponse.rawVisionResult = {
                error: true,
                message: this.sanitizeError(visionResult.reason),
              };
              this.logger.warn(
                `[DIRECT_EXTRACTION] Vision AI failed: ${this.sanitizeError(visionResult.reason)}`,
              );
            }

            if (documentAiOcrResult) {
              ocrResult.fullResponse.rawDocumentAiResult = this.serializeOcrResult(documentAiOcrResult);
              this.logger.log(
                `[DIRECT_EXTRACTION] Stored Document AI output for comparison`,
              );
            } else if (documentAiResult.status === 'rejected') {
              ocrResult.fullResponse.rawDocumentAiResult = {
                error: true,
                message: this.sanitizeError(documentAiResult.reason),
              };
              this.logger.warn(
                `[DIRECT_EXTRACTION] Document AI failed: ${this.sanitizeError(documentAiResult.reason)}`,
              );
            }
          } catch (ocrError) {
            // OCR failed but direct extraction succeeded - that's okay
            this.logger.warn(
              `[DIRECT_EXTRACTION] OCR parallel processing failed, but direct extraction succeeded: ${this.sanitizeError(ocrError)}`,
            );
            // Continue with direct extraction result only
          }
        } catch (pdf2jsonError) {
          // pdf2json failed - check error type for intelligent fallback
          const errorMessage = pdf2jsonError.message || String(pdf2jsonError);
          const isXRefError = errorMessage.includes(
            'Invalid XRef stream header',
          );

          this.logger.warn(`[PDF2JSON] pdf2json failed for ${documentId}`);
          this.logger.warn(`[PDF2JSON] Error details: ${errorMessage}`);
          this.logger.debug(
            `[PDF2JSON] Error stack: ${pdf2jsonError.stack || 'No stack trace'}`,
          );

          // Multi-tier fallback strategy:
          // 1. If XRef error, try pdf-parse (handles corrupted XRef better)
          // 2. If pdf-parse fails or other error, use OCR
          if (isXRefError) {
            this.logger.log(
              `[PDF-PARSE] pdf2json detected XRef error - trying pdf-parse as intermediate fallback...`,
            );

            try {
              // Try pdf-parse as fallback (more resilient to XRef issues)
              const pdfData = await pdfParse(fileBuffer);
              const extractedText = pdfData.text || '';

              this.logger.log(
                `[PDF-PARSE] pdf-parse extraction successful: ${extractedText.length} characters`,
              );

              // Check if we got meaningful text
              if (extractedText.trim().length >= 50) {
                // Success with pdf-parse!
                const entities = extractEntitiesFromText(extractedText);
                this.logger.log(
                  `[PDF-PARSE] Extracted ${entities.length} entities from text`,
                );

                ocrResult = {
                  text: extractedText,
                  confidence: 1.0, // Native text = 100% confidence
                  pageCount: pdfData.numpages || 1,
                  entities,
                  fullResponse: {
                    method: 'pdf_parse_extraction',
                    metadata: {
                      numPages: pdfData.numpages,
                      info: pdfData.info,
                      reason: 'pdf2json_xref_error_fallback',
                    },
                  },
                };

                processingMethod = ProcessingMethod.DIRECT_EXTRACTION;

                // Log for tracking problematic PDFs
                this.logger.log(
                  `[PDF-PARSE] Successfully recovered from XRef error for document ${documentId}`,
                );

                // Run OCR in parallel even when pdf-parse succeeds
                // This provides Vision and Document AI outputs for comparison
                this.logger.log(
                  `[PDF-PARSE] Running OCR in parallel for comparison outputs.`,
                );

                try {
                  const [visionResult, documentAiResult] = await Promise.allSettled([
                    this.visionOcrService.processDocument(
                      gcsUri,
                      mimeType,
                      document.pageCount,
                    ),
                    this.documentAiOcrService.processDocument(
                      gcsUri,
                      mimeType,
                      document.pageCount,
                    ),
                  ]);

                  const visionOcrResult =
                    visionResult.status === 'fulfilled' ? visionResult.value : null;
                  const documentAiOcrResult =
                    documentAiResult.status === 'fulfilled'
                      ? documentAiResult.value
                      : null;

                  // Store OCR results in fullResponse for comparison endpoints
                  if (!ocrResult.fullResponse || typeof ocrResult.fullResponse !== 'object') {
                    ocrResult.fullResponse = {};
                  }

                  // IMPORTANT: Serialize to avoid circular references
                  if (visionOcrResult) {
                    ocrResult.fullResponse.rawVisionResult = this.serializeOcrResult(visionOcrResult);
                  } else if (visionResult.status === 'rejected') {
                    ocrResult.fullResponse.rawVisionResult = {
                      error: true,
                      message: this.sanitizeError(visionResult.reason),
                    };
                  }

                  if (documentAiOcrResult) {
                    ocrResult.fullResponse.rawDocumentAiResult = this.serializeOcrResult(documentAiOcrResult);
                  } else if (documentAiResult.status === 'rejected') {
                    ocrResult.fullResponse.rawDocumentAiResult = {
                      error: true,
                      message: this.sanitizeError(documentAiResult.reason),
                    };
                  }
                } catch (ocrError) {
                  // OCR failed but pdf-parse succeeded - that's okay
                  this.logger.warn(
                    `[PDF-PARSE] OCR parallel processing failed, but pdf-parse succeeded: ${this.sanitizeError(ocrError)}`,
                  );
                }
              } else {
                // Not enough text even with pdf-parse - fall back to OCR
                throw new Error(
                  `Insufficient text from pdf-parse: ${extractedText.length} characters`,
                );
              }
            } catch (pdfParseError) {
              // pdf-parse also failed - fall back to parallel OCR
              this.logger.warn(
                `[PDF-PARSE] pdf-parse also failed for ${documentId}, falling back to parallel OCR`,
              );
              this.logger.warn(
                `[PDF-PARSE] Error: ${pdfParseError.message || pdfParseError}`,
              );

              const mergeEnabled =
                this.configService.get('documentProcessing.ocrMerge.enabled', {
                  infer: true,
                }) !== false;
              const postProcessingEnabled =
                this.configService.get(
                  'documentProcessing.ocrPostProcessing.enabled',
                  { infer: true },
                ) || false;

              if (mergeEnabled) {
                const [visionResult, documentAiResult] =
                  await Promise.allSettled([
                    this.visionOcrService.processDocument(
                      gcsUri,
                      mimeType,
                      document.pageCount,
                    ),
                    this.documentAiOcrService.processDocument(
                      gcsUri,
                      mimeType,
                      document.pageCount,
                    ),
                  ]);

                const visionOcrResult =
                  visionResult.status === 'fulfilled'
                    ? visionResult.value
                    : null;
                const documentAiOcrResult =
                  documentAiResult.status === 'fulfilled'
                    ? documentAiResult.value
                    : null;

                if (visionResult.status === 'rejected') {
                  this.logger.warn(
                    `[PARALLEL OCR] Vision AI failed: ${this.sanitizeError(visionResult.reason)}`,
                  );
                }

                if (documentAiResult.status === 'rejected') {
                  this.logger.warn(
                    `[PARALLEL OCR] Document AI failed: ${this.sanitizeError(documentAiResult.reason)}`,
                  );
                }

                if (visionOcrResult && documentAiOcrResult) {
                  ocrResult = await this.ocrMergeService.mergeOcrResults(
                    visionOcrResult,
                    documentAiOcrResult,
                    { enablePostProcessing: postProcessingEnabled },
                  );
                  // Store raw OCR results in fullResponse for comparison endpoints
                  if (ocrResult.fullResponse && typeof ocrResult.fullResponse === 'object') {
                    ocrResult.fullResponse.rawVisionResult = visionOcrResult;
                    ocrResult.fullResponse.rawDocumentAiResult = documentAiOcrResult;
                  }
                  processingMethod = ProcessingMethod.OCR_MERGED;
                } else if (visionOcrResult) {
                  ocrResult = visionOcrResult;
                  // Store Vision AI result for comparison endpoints
                  // Ensure fullResponse is an object
                  if (!ocrResult.fullResponse || typeof ocrResult.fullResponse !== 'object') {
                    ocrResult.fullResponse = {};
                  }
                  ocrResult.fullResponse.rawVisionResult = visionOcrResult;
                  // Also store Document AI failure info if it failed
                  if (documentAiResult.status === 'rejected') {
                    ocrResult.fullResponse.rawDocumentAiResult = {
                      error: true,
                      message: this.sanitizeError(documentAiResult.reason),
                    };
                  }
                  processingMethod = ProcessingMethod.OCR_VISION_SYNC;
                } else if (documentAiOcrResult) {
                  ocrResult = documentAiOcrResult;
                  // Store Document AI result for comparison endpoints
                  // Ensure fullResponse is an object
                  if (!ocrResult.fullResponse || typeof ocrResult.fullResponse !== 'object') {
                    ocrResult.fullResponse = {};
                  }
                  ocrResult.fullResponse.rawDocumentAiResult = documentAiOcrResult;
                  // Also store Vision AI failure info if it failed
                  if (visionResult.status === 'rejected') {
                    ocrResult.fullResponse.rawVisionResult = {
                      error: true,
                      message: this.sanitizeError(visionResult.reason),
                    };
                  }
                  processingMethod =
                    document.pageCount && document.pageCount <= 15
                      ? ProcessingMethod.OCR_SYNC
                      : ProcessingMethod.OCR_BATCH;
                } else {
                  throw new Error('Both OCR engines failed');
                }
              } else {
                // Merge disabled - but still run both OCRs in parallel for comparison
                this.logger.log(
                  `[PDF-PARSE FALLBACK] Merge disabled - running both OCRs in parallel (no merge)`,
                );

                // Run both OCRs in parallel even when merge is disabled
                const [visionResult, documentAiResult] =
                  await Promise.allSettled([
                    this.visionOcrService.processDocument(
                      gcsUri,
                      mimeType,
                      document.pageCount,
                    ),
                    this.documentAiOcrService.processDocument(
                      gcsUri,
                      mimeType,
                      document.pageCount,
                    ),
                  ]);

                const visionOcrResult =
                  visionResult.status === 'fulfilled'
                    ? visionResult.value
                    : null;
                const documentAiOcrResult =
                  documentAiResult.status === 'fulfilled'
                    ? documentAiResult.value
                    : null;

                if (visionResult.status === 'rejected') {
                  this.logger.warn(
                    `[PARALLEL OCR] Vision AI failed: ${this.sanitizeError(visionResult.reason)}`,
                  );
                }

                if (documentAiResult.status === 'rejected') {
                  this.logger.warn(
                    `[PARALLEL OCR] Document AI failed: ${this.sanitizeError(documentAiResult.reason)}`,
                  );
                }

                // Use best available result (prefer Document AI if both available, otherwise use whichever succeeded)
                if (documentAiOcrResult) {
                  ocrResult = documentAiOcrResult;
                  // Store both results for comparison endpoints
                  if (ocrResult.fullResponse && typeof ocrResult.fullResponse === 'object') {
                    ocrResult.fullResponse.rawDocumentAiResult = documentAiOcrResult;
                    if (visionOcrResult) {
                      ocrResult.fullResponse.rawVisionResult = visionOcrResult;
                    }
                  }
                  processingMethod =
                    document.pageCount && document.pageCount <= 15
                      ? ProcessingMethod.OCR_SYNC
                      : ProcessingMethod.OCR_BATCH;
                } else if (visionOcrResult) {
                  ocrResult = visionOcrResult;
                  // Store Vision AI result for comparison endpoints
                  // Ensure fullResponse is an object
                  if (!ocrResult.fullResponse || typeof ocrResult.fullResponse !== 'object') {
                    ocrResult.fullResponse = {};
                  }
                  ocrResult.fullResponse.rawVisionResult = visionOcrResult;
                  // Also store Document AI failure info if it failed
                  if (documentAiResult.status === 'rejected') {
                    ocrResult.fullResponse.rawDocumentAiResult = {
                      error: true,
                      message: this.sanitizeError(documentAiResult.reason),
                    };
                  }
                  processingMethod = ProcessingMethod.OCR_VISION_SYNC;
                } else {
                  throw new Error('Both OCR engines failed');
                }
              }

              this.logger.log(
                `[PDF PROCESSING] OCR fallback completed. Result has entities: ${!!ocrResult.entities}, count: ${ocrResult.entities?.length || 0}`,
              );
            }
          } else {
            // Not an XRef error - go directly to parallel OCR
            this.logger.log(
              `[PDF PROCESSING] Non-XRef error, falling back directly to parallel OCR`,
            );

            const mergeEnabled =
              this.configService.get('documentProcessing.ocrMerge.enabled', {
                infer: true,
              }) !== false;
            const postProcessingEnabled =
              this.configService.get(
                'documentProcessing.ocrPostProcessing.enabled',
                { infer: true },
              ) || false;

            if (mergeEnabled) {
              const [visionResult, documentAiResult] =
                await Promise.allSettled([
                  this.visionOcrService.processDocument(
                    gcsUri,
                    mimeType,
                    document.pageCount,
                  ),
                  this.documentAiOcrService.processDocument(
                    gcsUri,
                    mimeType,
                    document.pageCount,
                  ),
                ]);

              const visionOcrResult =
                visionResult.status === 'fulfilled' ? visionResult.value : null;
              const documentAiOcrResult =
                documentAiResult.status === 'fulfilled'
                  ? documentAiResult.value
                  : null;

              if (visionResult.status === 'rejected') {
                this.logger.warn(
                  `[PARALLEL OCR] Vision AI failed: ${this.sanitizeError(visionResult.reason)}`,
                );
              }

              if (documentAiResult.status === 'rejected') {
                this.logger.warn(
                  `[PARALLEL OCR] Document AI failed: ${this.sanitizeError(documentAiResult.reason)}`,
                );
              }

              if (visionOcrResult && documentAiOcrResult) {
                ocrResult = await this.ocrMergeService.mergeOcrResults(
                  visionOcrResult,
                  documentAiOcrResult,
                  { enablePostProcessing: postProcessingEnabled },
                );

                // Store raw OCR results in fullResponse for comparison endpoints
                // IMPORTANT: Serialize to avoid circular references
                if (ocrResult.fullResponse && typeof ocrResult.fullResponse === 'object') {
                  ocrResult.fullResponse.rawVisionResult = this.serializeOcrResult(visionOcrResult);
                  ocrResult.fullResponse.rawDocumentAiResult = this.serializeOcrResult(documentAiOcrResult);
                }

                processingMethod = ProcessingMethod.OCR_MERGED;
              } else if (visionOcrResult) {
                ocrResult = visionOcrResult;
                // Store Vision AI result for comparison endpoints
                // Ensure fullResponse is an object (it should be from Vision AI adapter)
                if (!ocrResult.fullResponse || typeof ocrResult.fullResponse !== 'object') {
                  ocrResult.fullResponse = {};
                }
                ocrResult.fullResponse.rawVisionResult = visionOcrResult;
                // Also store Document AI failure info if it failed
                if (documentAiResult.status === 'rejected') {
                  ocrResult.fullResponse.rawDocumentAiResult = {
                    error: true,
                    message: this.sanitizeError(documentAiResult.reason),
                  };
                }
                processingMethod = ProcessingMethod.OCR_VISION_SYNC;
              } else if (documentAiOcrResult) {
                ocrResult = documentAiOcrResult;
                // Store Document AI result for comparison endpoints
                // Ensure fullResponse is an object
                if (!ocrResult.fullResponse || typeof ocrResult.fullResponse !== 'object') {
                  ocrResult.fullResponse = {};
                }
                ocrResult.fullResponse.rawDocumentAiResult = documentAiOcrResult;
                // Also store Vision AI failure info if it failed
                if (visionResult.status === 'rejected') {
                  ocrResult.fullResponse.rawVisionResult = {
                    error: true,
                    message: this.sanitizeError(visionResult.reason),
                  };
                }
                processingMethod =
                  document.pageCount && document.pageCount <= 15
                    ? ProcessingMethod.OCR_SYNC
                    : ProcessingMethod.OCR_BATCH;
              } else {
                throw new Error('Both OCR engines failed');
              }
            } else {
              // Merge disabled - but still run both OCRs in parallel for comparison
              this.logger.log(
                `[PDF PROCESSING] Merge disabled - running both OCRs in parallel (no merge)`,
              );

              // Run both OCRs in parallel even when merge is disabled
              const [visionResult, documentAiResult] =
                await Promise.allSettled([
                  this.visionOcrService.processDocument(
                    gcsUri,
                    mimeType,
                    document.pageCount,
                  ),
                  this.documentAiOcrService.processDocument(
                    gcsUri,
                    mimeType,
                    document.pageCount,
                  ),
                ]);

              const visionOcrResult =
                visionResult.status === 'fulfilled' ? visionResult.value : null;
              const documentAiOcrResult =
                documentAiResult.status === 'fulfilled'
                  ? documentAiResult.value
                  : null;

              if (visionResult.status === 'rejected') {
                this.logger.warn(
                  `[PARALLEL OCR] Vision AI failed: ${this.sanitizeError(visionResult.reason)}`,
                );
              }

              if (documentAiResult.status === 'rejected') {
                this.logger.warn(
                  `[PARALLEL OCR] Document AI failed: ${this.sanitizeError(documentAiResult.reason)}`,
                );
              }

              // Use best available result (prefer Document AI if both available, otherwise use whichever succeeded)
              if (documentAiOcrResult) {
                ocrResult = documentAiOcrResult;
                // Store both results for comparison endpoints
                // Ensure fullResponse is an object
                if (!ocrResult.fullResponse || typeof ocrResult.fullResponse !== 'object') {
                  ocrResult.fullResponse = {};
                }
                ocrResult.fullResponse.rawDocumentAiResult = documentAiOcrResult;
                if (visionOcrResult) {
                  ocrResult.fullResponse.rawVisionResult = visionOcrResult;
                } else if (visionResult.status === 'rejected') {
                  // Store Vision AI failure info
                  ocrResult.fullResponse.rawVisionResult = {
                    error: true,
                    message: this.sanitizeError(visionResult.reason),
                  };
                }
                processingMethod =
                  document.pageCount && document.pageCount <= 15
                    ? ProcessingMethod.OCR_SYNC
                    : ProcessingMethod.OCR_BATCH;
              } else if (visionOcrResult) {
                ocrResult = visionOcrResult;
                // Store Vision AI result for comparison endpoints
                // Ensure fullResponse is an object
                if (!ocrResult.fullResponse || typeof ocrResult.fullResponse !== 'object') {
                  ocrResult.fullResponse = {};
                }
                ocrResult.fullResponse.rawVisionResult = visionOcrResult;
                // Store Document AI failure info if it failed
                if (documentAiResult.status === 'rejected') {
                  ocrResult.fullResponse.rawDocumentAiResult = {
                    error: true,
                    message: this.sanitizeError(documentAiResult.reason),
                  };
                }
                processingMethod = ProcessingMethod.OCR_VISION_SYNC;
              } else {
                throw new Error('Both OCR engines failed');
              }
            }

            this.logger.log(
              `[PDF PROCESSING] OCR fallback completed. Result has entities: ${!!ocrResult.entities}, count: ${ocrResult.entities?.length || 0}`,
            );
          }
        }
      } else {
        // Not a PDF or no buffer available - use parallel OCR with merge
        this.logger.log(
          `[PDF PROCESSING] Not a PDF or no buffer - using parallel OCR`,
        );

        // Check if merge is enabled
        const mergeEnabled =
          this.configService.get('documentProcessing.ocrMerge.enabled', {
            infer: true,
          }) !== false;
        const postProcessingEnabled =
          this.configService.get(
            'documentProcessing.ocrPostProcessing.enabled',
            { infer: true },
          ) || false;

        if (mergeEnabled) {
          // Run both OCRs in parallel
          this.logger.log(
            `[PARALLEL OCR] Starting parallel execution of Vision AI and Document AI`,
          );

          const [visionResult, documentAiResult] = await Promise.allSettled([
            this.visionOcrService.processDocument(
              gcsUri,
              mimeType,
              document.pageCount,
            ),
            this.documentAiOcrService.processDocument(
              gcsUri,
              mimeType,
              document.pageCount,
            ),
          ]);

          const visionOcrResult =
            visionResult.status === 'fulfilled' ? visionResult.value : null;
          const documentAiOcrResult =
            documentAiResult.status === 'fulfilled'
              ? documentAiResult.value
              : null;

          // Handle results
          if (visionResult.status === 'rejected') {
            this.logger.warn(
              `[PARALLEL OCR] Vision AI failed: ${this.sanitizeError(visionResult.reason)}`,
            );
          }

          if (documentAiResult.status === 'rejected') {
            this.logger.warn(
              `[PARALLEL OCR] Document AI failed: ${this.sanitizeError(documentAiResult.reason)}`,
            );
          }

          // Merge if both succeeded
          if (visionOcrResult && documentAiOcrResult) {
            this.logger.log(
              `[PARALLEL OCR] Both OCRs succeeded, merging results`,
            );

            ocrResult = await this.ocrMergeService.mergeOcrResults(
              visionOcrResult,
              documentAiOcrResult,
              { enablePostProcessing: postProcessingEnabled },
            );

            // Store raw OCR results in fullResponse for comparison endpoints
            // IMPORTANT: Serialize to avoid circular references
            if (ocrResult.fullResponse && typeof ocrResult.fullResponse === 'object') {
              ocrResult.fullResponse.rawVisionResult = this.serializeOcrResult(visionOcrResult);
              ocrResult.fullResponse.rawDocumentAiResult = this.serializeOcrResult(documentAiOcrResult);
            }

            processingMethod = ProcessingMethod.OCR_MERGED;
          } else if (visionOcrResult) {
            // Only Vision AI succeeded
            this.logger.log(
              `[PARALLEL OCR] Only Vision AI succeeded, using Vision result`,
            );
            ocrResult = visionOcrResult;
            // Store Vision AI result for comparison endpoints
            // Ensure fullResponse is an object (it should be from Vision AI adapter)
            if (!ocrResult.fullResponse || typeof ocrResult.fullResponse !== 'object') {
              ocrResult.fullResponse = {};
            }
            // IMPORTANT: Serialize to avoid circular references
            ocrResult.fullResponse.rawVisionResult = this.serializeOcrResult(visionOcrResult);
            // Also store Document AI failure info if it failed
            if (documentAiResult.status === 'rejected') {
              ocrResult.fullResponse.rawDocumentAiResult = {
                error: true,
                message: this.sanitizeError(documentAiResult.reason),
              };
            }
            processingMethod = ProcessingMethod.OCR_VISION_SYNC;
          } else if (documentAiOcrResult) {
            // Only Document AI succeeded
            this.logger.log(
              `[PARALLEL OCR] Only Document AI succeeded, using Document AI result`,
            );
            ocrResult = documentAiOcrResult;
            // Store Document AI result for comparison endpoints
            // Ensure fullResponse is an object
            if (!ocrResult.fullResponse || typeof ocrResult.fullResponse !== 'object') {
              ocrResult.fullResponse = {};
            }
            // IMPORTANT: Serialize to avoid circular references
            ocrResult.fullResponse.rawDocumentAiResult = this.serializeOcrResult(documentAiOcrResult);
            // Also store Vision AI failure info if it failed
            if (visionResult.status === 'rejected') {
              ocrResult.fullResponse.rawVisionResult = {
                error: true,
                message: this.sanitizeError(visionResult.reason),
              };
            }
            processingMethod =
              document.pageCount && document.pageCount <= 15
                ? ProcessingMethod.OCR_SYNC
                : ProcessingMethod.OCR_BATCH;
          } else {
            // Both failed
            throw new Error('Both OCR engines failed');
          }
        } else {
          // Merge disabled - but still run both OCRs in parallel for comparison
          this.logger.log(
            `[PDF PROCESSING] Merge disabled - running both OCRs in parallel (no merge)`,
          );

          // Run both OCRs in parallel even when merge is disabled
          const [visionResult, documentAiResult] = await Promise.allSettled([
            this.visionOcrService.processDocument(
              gcsUri,
              mimeType,
              document.pageCount,
            ),
            this.documentAiOcrService.processDocument(
              gcsUri,
              mimeType,
              document.pageCount,
            ),
          ]);

          const visionOcrResult =
            visionResult.status === 'fulfilled' ? visionResult.value : null;
          const documentAiOcrResult =
            documentAiResult.status === 'fulfilled'
              ? documentAiResult.value
              : null;

          // Handle results
          if (visionResult.status === 'rejected') {
            this.logger.warn(
              `[PARALLEL OCR] Vision AI failed: ${this.sanitizeError(visionResult.reason)}`,
            );
          }

          if (documentAiResult.status === 'rejected') {
            this.logger.warn(
              `[PARALLEL OCR] Document AI failed: ${this.sanitizeError(documentAiResult.reason)}`,
            );
          }

          // Use best available result (prefer Document AI if both available, otherwise use whichever succeeded)
          if (documentAiOcrResult) {
            ocrResult = documentAiOcrResult;
            // Store both results for comparison endpoints
            // Ensure fullResponse is an object
            if (!ocrResult.fullResponse || typeof ocrResult.fullResponse !== 'object') {
              ocrResult.fullResponse = {};
            }
            // IMPORTANT: Serialize to avoid circular references
            ocrResult.fullResponse.rawDocumentAiResult = this.serializeOcrResult(documentAiOcrResult);
            if (visionOcrResult) {
              ocrResult.fullResponse.rawVisionResult = this.serializeOcrResult(visionOcrResult);
            } else if (visionResult.status === 'rejected') {
              // Store Vision AI failure info
              ocrResult.fullResponse.rawVisionResult = {
                error: true,
                message: this.sanitizeError(visionResult.reason),
              };
            }
            processingMethod =
              document.pageCount && document.pageCount <= 15
                ? ProcessingMethod.OCR_SYNC
                : ProcessingMethod.OCR_BATCH;
          } else if (visionOcrResult) {
            ocrResult = visionOcrResult;
            // Store Vision AI result for comparison endpoints
            // Ensure fullResponse is an object
            if (!ocrResult.fullResponse || typeof ocrResult.fullResponse !== 'object') {
              ocrResult.fullResponse = {};
            }
            // IMPORTANT: Serialize to avoid circular references
            ocrResult.fullResponse.rawVisionResult = this.serializeOcrResult(visionOcrResult);
            // Store Document AI failure info if it failed
            if (documentAiResult.status === 'rejected') {
              ocrResult.fullResponse.rawDocumentAiResult = {
                error: true,
                message: this.sanitizeError(documentAiResult.reason),
              };
            }
            processingMethod = ProcessingMethod.OCR_VISION_SYNC;
          } else {
            throw new Error('Both OCR engines failed');
          }

          this.logger.log(
            `[PDF PROCESSING] Parallel OCR completed (no merge). Result has entities: ${!!ocrResult.entities}, count: ${ocrResult.entities?.length || 0}`,
          );
        }
      }

      this.logger.log(
        `[PDF PROCESSING] Processing method determined: ${processingMethod}`,
      );

      // Store processed output JSON
      // Serialize fullResponse to avoid circular references when storing
      const serializedFullResponse = this.serializeFullResponse(ocrResult.fullResponse);

      const processedUri = await this.storageService.storeProcessed(
        serializedFullResponse,
        {
          documentId,
          userId: document.userId,
          fileName: `${documentId}.json`,
          mimeType: 'application/json',
          contentLength: JSON.stringify(serializedFullResponse).length,
        },
      );

      // Extract and save structured fields
      await this.extractAndSaveFields(documentId, ocrResult);

      // Update document with results
      // Log what we're about to store (before serialization)
      this.logger.log(
        `[STORAGE] Before saving ocrJsonOutput for document ${documentId}`,
      );
      this.logger.debug(
        `[STORAGE] fullResponse keys: ${ocrResult.fullResponse ? Object.keys(ocrResult.fullResponse).join(', ') : 'null'}`,
      );
      this.logger.debug(
        `[STORAGE] Has rawVisionResult: ${!!ocrResult.fullResponse?.rawVisionResult}`,
      );
      this.logger.debug(
        `[STORAGE] Has rawDocumentAiResult: ${!!ocrResult.fullResponse?.rawDocumentAiResult}`,
      );
      this.logger.debug(
        `[STORAGE] Processing method: ${processingMethod}`,
      );

      // Serialize fullResponse before storing in database to avoid circular references
      const serializedOcrJsonOutput = this.serializeFullResponse(ocrResult.fullResponse);

      // Log what we're actually storing (after serialization)
      if (serializedOcrJsonOutput) {
        this.logger.debug(
          `[STORAGE] Serialized ocrJsonOutput keys: ${Object.keys(serializedOcrJsonOutput).join(', ')}`,
        );
        this.logger.debug(
          `[STORAGE] Serialized has rawVisionResult: ${!!serializedOcrJsonOutput.rawVisionResult}`,
        );
        this.logger.debug(
          `[STORAGE] Serialized has rawDocumentAiResult: ${!!serializedOcrJsonOutput.rawDocumentAiResult}`,
        );
      } else {
        this.logger.warn(
          `[STORAGE] WARNING: serializedOcrJsonOutput is null! This will cause retrieval issues.`,
        );
      }

      await this.documentRepository.updateStatus(
        documentId,
        DocumentStatus.PROCESSED,
        {
          processedFileUri: processedUri,
          ocrJsonOutput: serializedOcrJsonOutput,
          extractedText: ocrResult.text,
          confidence: ocrResult.confidence,
          pageCount: ocrResult.pageCount,
          processedAt: new Date(),
          processingMethod,
        },
      );

      this.logger.log(
        `[STORAGE] Successfully saved ocrJsonOutput for document ${documentId}`,
      );

      // Audit log
      this.auditService.logAuthEvent({
        userId: document.userId,
        provider: 'document-processing',
        event: DocumentEventType.DOCUMENT_PROCESSING_COMPLETED as any,
        success: true,
        metadata: {
          documentId,
          confidence: ocrResult.confidence,
          entitiesCount: ocrResult.entities?.length || 0,
        },
      });

      this.logger.log(`Processing complete for document ${documentId}`);
    } catch (error) {
      await this.handleProcessingError(documentId, error);
    }
  }

  /**
   * Extract structured fields from OCR result
   */
  private async extractAndSaveFields(
    documentId: string,
    ocrResult: any,
  ): Promise<void> {
    this.logger.log(
      `[FIELD EXTRACTION] Starting field extraction for document ${documentId}`,
    );
    this.logger.log(
      `[FIELD EXTRACTION] OCR result structure: ${JSON.stringify({
        hasEntities: !!ocrResult.entities,
        entitiesCount: ocrResult.entities?.length || 0,
        hasFullResponse: !!ocrResult.fullResponse,
        keys: Object.keys(ocrResult),
      })}`,
    );

    if (!ocrResult.entities || ocrResult.entities.length === 0) {
      this.logger.warn(
        `[FIELD EXTRACTION] No entities found in OCR result for document ${documentId}`,
      );
      return;
    }

    const fields: ExtractedField[] = [];
    let lowConfidenceCount = 0;

    for (const entity of ocrResult.entities) {
      this.logger.debug(
        `[FIELD EXTRACTION] Processing entity: ${JSON.stringify({
          type: entity.type,
          mentionText: entity.mentionText?.substring(0, 50),
          confidence: entity.confidence,
        })}`,
      );

      // CHANGED: Save ALL entities, including low-confidence ones
      // This gives users visibility into all data the model extracted
      const field = new ExtractedField();
      // NOTE: ID will be auto-generated by database as UUID
      field.documentId = documentId;
      field.fieldKey = this.normalizeEntityType(entity.type);
      field.fieldValue = entity.mentionText;
      field.fieldType = this.mapToFieldType(entity.type);
      field.confidence = entity.confidence;
      field.startIndex = entity.startOffset;
      field.endIndex = entity.endOffset;
      field.createdAt = new Date();
      field.updatedAt = new Date();

      fields.push(field);

      // Track low-confidence fields for logging
      if (entity.confidence < 0.7) {
        lowConfidenceCount++;
      }

      this.logger.debug(
        `[FIELD EXTRACTION] Added field: ${field.fieldKey} = ${field.fieldValue?.substring(0, 50)} (confidence: ${field.confidence})`,
      );
    }

    this.logger.log(
      `[FIELD EXTRACTION] Extraction complete: ${fields.length} fields to save (${lowConfidenceCount} low-confidence included)`,
    );

    if (fields.length > 0) {
      this.logger.log(
        `[FIELD EXTRACTION] Saving ${fields.length} fields to database...`,
      );
      await this.documentRepository.saveExtractedFields(fields);
      this.logger.log(
        `[FIELD EXTRACTION] Successfully saved ${fields.length} extracted fields for document ${documentId}`,
      );
    } else {
      this.logger.warn(
        `[FIELD EXTRACTION] No fields to save for document ${documentId} (all filtered out or none extracted)`,
      );
    }
  }

  /**
   * Handle processing errors
   */
  private async handleProcessingError(
    documentId: string,
    error: any,
  ): Promise<void> {
    const document = await this.documentRepository.findById(documentId);
    if (!document) return;

    const retryCount = (document.retryCount || 0) + 1;
    const errorMessage = this.sanitizeError(error);

    if (retryCount < this.maxRetryCount) {
      // Retry
      this.logger.warn(
        `Processing failed for document ${documentId}, retry ${retryCount}/${this.maxRetryCount}`,
      );

      await this.documentRepository.update(documentId, {
        retryCount,
        errorMessage,
        status: DocumentStatus.QUEUED,
      });

      // Retry after delay (note: no buffer available on retry, will use OCR)
      setTimeout(() => {
        this.startProcessing(
          documentId,
          document.rawFileUri,
          document.mimeType,
        ).catch(() => {});
      }, 30000 * retryCount); // Exponential backoff: 30s, 60s, 90s
    } else {
      // Mark as failed
      await this.documentRepository.updateStatus(
        documentId,
        DocumentStatus.FAILED,
        {
          errorMessage,
          retryCount,
        },
      );

      // Audit log
      this.auditService.logAuthEvent({
        userId: document.userId,
        provider: 'document-processing',
        event: DocumentEventType.DOCUMENT_PROCESSING_FAILED as any,
        success: false,
        errorMessage,
        metadata: { documentId, retryCount },
      });

      this.logger.error(
        `Processing permanently failed for document ${documentId}`,
      );
    }
  }

  /**
   * Get document by ID (with authorization check)
   */
  async getDocument(
    documentId: string,
    userId: string | number,
  ): Promise<Document> {
    // Debug: Check if document exists at all
    const documentExists = await this.documentRepository.findById(documentId);

    this.logger.debug(
      `[AUTH] Checking access: documentId=${documentId}, requestUserId=${userId}, documentExists=${!!documentExists}, documentOwnerId=${documentExists?.userId}`,
    );

    const document = await this.documentRepository.findByIdAndUserId(
      documentId,
      userId,
    );

    if (!document) {
      // Log detailed info for debugging
      if (documentExists) {
        this.logger.warn(
          `[AUTH] Document ${documentId} exists but belongs to user ${documentExists.userId}, not ${userId}`,
        );
      } else {
        this.logger.warn(
          `[AUTH] Document ${documentId} does not exist in database`,
        );
      }

      // Audit log unauthorized access attempt
      this.auditService.logAuthEvent({
        userId,
        provider: 'document-processing',
        event: DocumentEventType.UNAUTHORIZED_DOCUMENT_ACCESS as any,
        success: false,
        metadata: {
          documentId,
          documentExists: !!documentExists,
          documentOwnerId: documentExists?.userId,
        },
      });

      throw new NotFoundException('Document not found');
    }

    // Audit log access
    this.auditService.logAuthEvent({
      userId,
      provider: 'document-processing',
      event: DocumentEventType.DOCUMENT_ACCESSED as any,
      success: true,
      metadata: { documentId },
    });

    return document;
  }

  /**
   * List user's documents
   */
  async listDocuments(
    userId: string | number,
    options?: { page?: number; limit?: number; status?: DocumentStatus[] },
  ): Promise<{ data: Document[]; total: number; page: number; limit: number }> {
    const page = options?.page || 1;
    const limit = options?.limit || 20;
    const skip = (page - 1) * limit;

    const result = await this.documentRepository.findByUserId(userId, {
      skip,
      limit,
      status: options?.status,
    });

    return {
      ...result,
      page,
      limit,
    };
  }

  /**
   * Soft delete document
   */
  async deleteDocument(
    documentId: string,
    userId: string | number,
  ): Promise<void> {
    const document = await this.getDocument(documentId, userId); // Checks authorization

    if (document.deletedAt) {
      throw new ForbiddenException('Document already deleted');
    }

    const scheduledDeletionAt = new Date();
    scheduledDeletionAt.setFullYear(
      scheduledDeletionAt.getFullYear() + this.retentionYears,
    );

    await this.documentRepository.update(documentId, {
      deletedAt: new Date(),
      scheduledDeletionAt,
    });

    // Audit log
    this.auditService.logAuthEvent({
      userId,
      provider: 'document-processing',
      event: DocumentEventType.DOCUMENT_DELETED as any,
      success: true,
      metadata: {
        documentId,
        scheduledDeletionAt: scheduledDeletionAt.toISOString(),
      },
    });

    this.logger.log(
      `Document soft-deleted: ${documentId} (hard delete at ${scheduledDeletionAt.toISOString()})`,
    );
  }

  /**
   * Generate signed download URL
   */
  async getDownloadUrl(
    documentId: string,
    userId: string | number,
  ): Promise<string> {
    const document = await this.getDocument(documentId, userId); // Checks authorization

    if (!document.rawFileUri) {
      throw new NotFoundException('Document file not available');
    }

    return this.storageService.getSignedUrl(document.rawFileUri, 86400); // 24 hours
  }

  /**
   * Get extracted fields for document
   */
  async getExtractedFields(
    documentId: string,
    userId: string | number,
  ): Promise<ExtractedField[]> {
    this.logger.log(
      `[FIELD RETRIEVAL] Getting extracted fields for document ${documentId}`,
    );
    await this.getDocument(documentId, userId); // Authorization check
    const fields =
      await this.documentRepository.findExtractedFieldsByDocumentId(documentId);
    this.logger.log(
      `[FIELD RETRIEVAL] Found ${fields.length} fields for document ${documentId}`,
    );
    if (fields.length > 0) {
      this.logger.debug(
        `[FIELD RETRIEVAL] Sample field: ${JSON.stringify({
          fieldKey: fields[0].fieldKey,
          fieldValue: fields[0].fieldValue?.substring(0, 50),
          fieldType: fields[0].fieldType,
          confidence: fields[0].confidence,
        })}`,
      );
    }
    return fields;
  }

  /**
   * Get Vision AI OCR output for document
   */
  async getVisionAiOutput(
    documentId: string,
    userId: string | number,
  ): Promise<any> {
    const document = await this.getDocument(documentId, userId); // Authorization check

    if (!document.ocrJsonOutput) {
      this.logger.debug(
        `[VISION AI RETRIEVAL] No ocrJsonOutput for document ${documentId}`,
      );
      throw new NotFoundException('OCR output not available for this document');
    }

    // Log what we have for debugging
    this.logger.debug(
      `[VISION AI RETRIEVAL] Document ${documentId} - Processing method: ${document.processingMethod}`,
    );
    this.logger.debug(
      `[VISION AI RETRIEVAL] ocrJsonOutput keys: ${Object.keys(document.ocrJsonOutput || {}).join(', ')}`,
    );
    this.logger.debug(
      `[VISION AI RETRIEVAL] Has rawVisionResult: ${!!document.ocrJsonOutput?.rawVisionResult}`,
    );
    this.logger.debug(
      `[VISION AI RETRIEVAL] Has sources.vision: ${!!document.ocrJsonOutput?.sources?.vision}`,
    );

    // Extract Vision AI result from stored OCR output
    const rawVisionResult =
      document.ocrJsonOutput?.rawVisionResult ||
      document.ocrJsonOutput?.sources?.vision;

    if (!rawVisionResult) {
      // Fallback: if document was processed with Vision AI only, return full response
      if (document.processingMethod === ProcessingMethod.OCR_VISION_SYNC) {
        this.logger.debug(
          `[VISION AI RETRIEVAL] Fallback: returning full ocrJsonOutput for OCR_VISION_SYNC`,
        );
        const result = document.ocrJsonOutput;
        // Sanitize fullResponse to remove image fields from pages
        if (result?.fullResponse) {
          result.fullResponse = this.sanitizeFullResponse(result.fullResponse);
        }
        return result;
      }

      // Check if there's an error object stored
      const visionError = document.ocrJsonOutput?.rawVisionResult;
      if (visionError && visionError.error === true) {
        this.logger.debug(
          `[VISION AI RETRIEVAL] Returning Vision AI error object`,
        );
        return visionError;
      }

      // For DIRECT_EXTRACTION: OCR may not have been run or may have failed
      if (document.processingMethod === ProcessingMethod.DIRECT_EXTRACTION) {
        this.logger.debug(
          `[VISION AI RETRIEVAL] DIRECT_EXTRACTION document - OCR may not have been run or may have failed`,
        );
        throw new NotFoundException(
          'Vision AI output not available. Document was processed with direct extraction and OCR was not run or failed.',
        );
      }

      this.logger.warn(
        `[VISION AI RETRIEVAL] Vision AI output not found for document ${documentId}. Processing method: ${document.processingMethod}`,
      );
      throw new NotFoundException(
        'Vision AI output not available. Document may not have been processed with parallel OCR merge.',
      );
    }

    this.logger.debug(
      `[VISION AI RETRIEVAL] Successfully retrieved Vision AI output for document ${documentId}`,
    );

    // Sanitize fullResponse to remove image fields from pages before returning
    if (rawVisionResult?.fullResponse) {
      rawVisionResult.fullResponse = this.sanitizeFullResponse(
        rawVisionResult.fullResponse,
      );
    }

    return rawVisionResult;
  }

  /**
   * Get Document AI OCR output for document
   */
  async getDocumentAiOutput(
    documentId: string,
    userId: string | number,
  ): Promise<any> {
    const document = await this.getDocument(documentId, userId); // Authorization check

    if (!document.ocrJsonOutput) {
      this.logger.debug(
        `[DOCUMENT AI RETRIEVAL] No ocrJsonOutput for document ${documentId}`,
      );
      throw new NotFoundException('OCR output not available for this document');
    }

    // Log what we have for debugging
    this.logger.debug(
      `[DOCUMENT AI RETRIEVAL] Document ${documentId} - Processing method: ${document.processingMethod}`,
    );
    this.logger.debug(
      `[DOCUMENT AI RETRIEVAL] ocrJsonOutput keys: ${Object.keys(document.ocrJsonOutput || {}).join(', ')}`,
    );
    this.logger.debug(
      `[DOCUMENT AI RETRIEVAL] Has rawDocumentAiResult: ${!!document.ocrJsonOutput?.rawDocumentAiResult}`,
    );
    this.logger.debug(
      `[DOCUMENT AI RETRIEVAL] Has sources.documentAi: ${!!document.ocrJsonOutput?.sources?.documentAi}`,
    );

    // Extract Document AI result from stored OCR output
    const rawDocumentAiResult =
      document.ocrJsonOutput?.rawDocumentAiResult ||
      document.ocrJsonOutput?.sources?.documentAi;

    if (!rawDocumentAiResult) {
      // Fallback: if document was processed with single OCR (Document AI), return full response
      if (
        document.processingMethod === 'OCR_SYNC' ||
        document.processingMethod === 'OCR_BATCH'
      ) {
        const result = document.ocrJsonOutput;
        // Sanitize fullResponse to remove image fields from pages
        if (result?.fullResponse) {
          result.fullResponse = this.sanitizeFullResponse(result.fullResponse);
        }
        return result;
      }

      // For OCR_VISION_SYNC: Document AI was not used or failed
      // Check if we stored an error object for Document AI failure
      if (document.processingMethod === ProcessingMethod.OCR_VISION_SYNC) {
        // Check if there's an error object stored
        const documentAiError = document.ocrJsonOutput?.rawDocumentAiResult;
        if (documentAiError && documentAiError.error === true) {
          this.logger.debug(
            `[DOCUMENT AI RETRIEVAL] Returning Document AI error object for OCR_VISION_SYNC`,
          );
          return documentAiError;
        }
        this.logger.debug(
          `[DOCUMENT AI RETRIEVAL] No Document AI result for OCR_VISION_SYNC`,
        );
        return null;
      }

      // For DIRECT_EXTRACTION: OCR may not have been run or may have failed
      if (document.processingMethod === ProcessingMethod.DIRECT_EXTRACTION) {
        this.logger.debug(
          `[DOCUMENT AI RETRIEVAL] DIRECT_EXTRACTION document - OCR may not have been run or may have failed`,
        );
        throw new NotFoundException(
          'Document AI output not available. Document was processed with direct extraction and OCR was not run or failed.',
        );
      }

      throw new NotFoundException(
        'Document AI output not available. Document may not have been processed with parallel OCR merge.',
      );
    }

    this.logger.debug(
      `[DOCUMENT AI RETRIEVAL] Successfully retrieved Document AI output for document ${documentId}`,
    );

    // Sanitize fullResponse to remove image fields from pages before returning
    if (rawDocumentAiResult?.fullResponse) {
      rawDocumentAiResult.fullResponse = this.sanitizeFullResponse(
        rawDocumentAiResult.fullResponse,
      );
    }

    return rawDocumentAiResult;
  }

  /**
   * Scheduled job: Hard delete documents after retention period
   * Runs daily at 3:00 AM UTC
   *
   * HIPAA Compliance:
   * - Deletes both GCS files and database records
   * - Logs all deletions for audit trail
   * - Retains audit logs even after document deletion
   */
  @Cron(CronExpression.EVERY_DAY_AT_3AM)
  async cleanupExpiredDocuments(): Promise<void> {
    this.logger.log('Starting scheduled document cleanup job...');

    try {
      const expiredDocuments = await this.documentRepository.findExpired();

      if (expiredDocuments.length === 0) {
        this.logger.log('No expired documents to clean up');
        return;
      }

      this.logger.log(
        `Found ${expiredDocuments.length} expired documents to delete`,
      );

      let successCount = 0;
      let failureCount = 0;

      for (const document of expiredDocuments) {
        try {
          // 1. Delete raw file from GCS
          if (document.rawFileUri) {
            await this.storageService.delete(document.rawFileUri);
          }

          // 2. Delete processed file from GCS (if exists)
          if (document.processedFileUri) {
            await this.storageService.delete(document.processedFileUri);
          }

          // 3. Hard delete from database (cascade deletes extracted_fields)
          await this.documentRepository.hardDelete(document.id);

          // 4. Audit log (CRITICAL: Log persists even after document deletion)
          this.auditService.logAuthEvent({
            userId: document.userId,
            provider: 'document-processing',
            event: DocumentEventType.DOCUMENT_HARD_DELETED as any,
            success: true,
            metadata: {
              documentId: document.id,
              documentType: document.documentType,
              deletedAt: document.deletedAt?.toISOString(),
              retentionYears: this.retentionYears,
              reason: 'scheduled_cleanup',
            },
          });

          successCount++;
          this.logger.debug(`Hard deleted document ${document.id}`);
        } catch (error) {
          failureCount++;
          this.logger.error(
            `Failed to hard delete document ${document.id}: ${error.message}`,
          );

          // Log failure but continue with other documents
          this.auditService.logAuthEvent({
            userId: document.userId,
            provider: 'document-processing',
            event: DocumentEventType.DOCUMENT_HARD_DELETED as any,
            success: false,
            errorMessage: this.sanitizeError(error),
            metadata: {
              documentId: document.id,
              reason: 'scheduled_cleanup_failed',
            },
          });
        }
      }

      this.logger.log(
        `Cleanup job complete: ${successCount} deleted, ${failureCount} failed`,
      );
    } catch (error) {
      this.logger.error(`Cleanup job failed: ${error.message}`);
    }
  }

  // Helper methods

  private normalizeEntityType(type: string): string {
    // Map Document AI entity types to our field keys
    const mapping: Record<string, string> = {
      person_name: 'patient_name',
      date: 'test_date',
      number: 'result_value',
      // TODO: Add more mappings based on processor configuration
    };

    return mapping[type] || type;
  }

  private mapToFieldType(entityType: string): string {
    if (entityType.includes('date')) return 'date';
    if (entityType.includes('number') || entityType.includes('quantity'))
      return 'number';
    return 'string';
  }

  private sanitizeError(error: any): string {
    const message = error?.message || String(error);
    return message
      .replace(/gs:\/\/[^\s]+/g, '[URI_REDACTED]')
      .replace(/projects\/[^\/\s]+/g, '[PROJECT_REDACTED]')
      .substring(0, 500);
  }

  /**
   * Sanitize fullResponse by removing image fields from pages
   * This reduces payload size and avoids exposing image data
   */
  private sanitizeFullResponse(fullResponse: any): any {
    if (!fullResponse) {
      return fullResponse;
    }

    try {
      // Deep clone to avoid mutating original
      const seen = new WeakSet();
      const sanitized = JSON.parse(
        JSON.stringify(fullResponse, (key, value) => {
          // Skip circular references
          if (typeof value === 'object' && value !== null) {
            if (seen.has(value)) {
              return '[Circular Reference]';
            }
            seen.add(value);
          }
          return value;
        }),
      );

      // Remove image field from pages array
      if (sanitized && Array.isArray(sanitized.pages)) {
        sanitized.pages = sanitized.pages.map((page: any) => {
          if (page && typeof page === 'object') {
            const { image, ...pageWithoutImage } = page;
            return pageWithoutImage;
          }
          return page;
        });
      }

      return sanitized;
    } catch (error) {
      // If sanitization fails, return original (will be handled by caller)
      this.logger.warn(
        `Failed to sanitize fullResponse: ${this.sanitizeError(error)}. Returning original.`,
      );
      return fullResponse;
    }
  }

  /**
   * Serialize OCR result to avoid circular references when storing in database
   * Creates a clean copy without circular references
   */
  private serializeOcrResult(ocrResult: any): any {
    if (!ocrResult) {
      return null;
    }

    try {
      // Create a clean copy with only the data we need
      const serialized: any = {
        text: ocrResult.text,
        confidence: ocrResult.confidence,
        pageCount: ocrResult.pageCount,
        entities: ocrResult.entities ? [...ocrResult.entities] : undefined,
        outputRef: ocrResult.outputRef,
      };

      // Safely serialize fullResponse (which may contain circular references)
      // and remove image fields from pages
      if (ocrResult.fullResponse) {
        serialized.fullResponse = this.sanitizeFullResponse(
          ocrResult.fullResponse,
        );
      }

      return serialized;
    } catch (error) {
      // If serialization fails, return a minimal safe structure
      this.logger.warn(
        `Failed to serialize OCR result: ${this.sanitizeError(error)}. Returning minimal structure.`,
      );
      return {
        text: ocrResult.text,
        confidence: ocrResult.confidence,
        pageCount: ocrResult.pageCount,
        entities: ocrResult.entities,
        fullResponse: '[Serialization Error]',
      };
    }
  }

  /**
   * Serialize fullResponse object to avoid circular references
   * Used when storing ocrJsonOutput in database
   * Uses a recursive approach to properly handle circular references
   */
  private serializeFullResponse(fullResponse: any): any {
    if (!fullResponse) {
      return null;
    }

    try {
      // First, try standard JSON.stringify (fast path)
      return JSON.parse(JSON.stringify(fullResponse));
    } catch (error) {
      // If circular reference error, use recursive approach
      if (
        error instanceof TypeError &&
        (error.message.includes('circular') ||
          error.message.includes('Converting circular'))
      ) {
        this.logger.debug(
          `Circular reference detected in fullResponse. Using recursive serialization.`,
        );
        return this.serializeObjectRecursive(fullResponse);
      }
      // For other errors, log and return null
      this.logger.warn(
        `Failed to serialize fullResponse: ${this.sanitizeError(error)}. Returning null.`,
      );
      return null;
    }
  }

  /**
   * Recursively serialize object while handling circular references
   */
  private serializeObjectRecursive(obj: any, seen = new WeakSet()): any {
    // Handle primitives
    if (obj === null || typeof obj !== 'object') {
      return obj;
    }

    // Handle circular references
    if (seen.has(obj)) {
      return '[Circular Reference]';
    }

    seen.add(obj);

    // Handle arrays
    if (Array.isArray(obj)) {
      return obj.map((item) => this.serializeObjectRecursive(item, seen));
    }

    // Handle objects
    const result: any = {};
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        try {
          result[key] = this.serializeObjectRecursive(obj[key], seen);
        } catch (error) {
          // If we can't serialize a property, skip it
          result[key] = '[Serialization Error]';
        }
      }
    }

    return result;
  }
}
